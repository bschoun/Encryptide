using Riptide;
using Riptide.Transports;
using Riptide.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;

namespace Encryptide
{
    public enum Encryption : byte
    {
        None, 
        Aes, 
        Default
    }
    public class Server : Riptide.Server
    {
        /// <summary>
        /// RSA (asymmetric) key. 
        /// Public RSA key will be sent to clients when they attempt to connect.
        /// </summary>
        private RSA rsa;

        /// <summary>
        /// AES (symmetric) key. 
        /// This is generated by the server and sent to clients (encrypted using the client's pub RSA key) when the connection is accepted.
        /// </summary>
        private Aes aes;

        /// <summary>
        /// A string that needs to match between client and server to validate the connection.
        /// </summary>
        public string AppSecret { private get; set; } = null;

        /// <summary>
        /// Dictionary of pending connections.
        /// </summary>
        private Dictionary<string, Connection> pendingConnections = new Dictionary<string, Connection>();

        /// <summary>
        /// Dictionary of pending connections' encryption (RSA) keys.
        /// </summary>
        private Dictionary<string, RSA> pendingConnectionsEncryptionData = new Dictionary<string, RSA>();

        /// <summary>
        /// Whether to encrypt data by default.
        /// </summary>
        private bool encryptByDefault = false;

        /// <summary>
        /// Whether to randomly generate PIN number on creation.
        /// </summary>
        private bool randomPin = false;

        /// <summary>
        /// List of relay filter ids.
        /// </summary>
        private List<ushort> relayFilterIds;

        /// <summary>
        /// PIN number for authenticating connection. Default is 1234.
        /// </summary>
        public string PinNumber = "1234";

        /// <summary>
        /// Random number generator for PIN number.
        /// </summary>
        private System.Random _random = new System.Random();

        /// <summary>
        /// Access to base RelayFilter.
        /// </summary>
        private MessageRelayFilter relayFilter
        {
            get
            {
                return base.RelayFilter;
            }
            set 
            {
                base.RelayFilter = value;
            }
        }

        /// <summary>
        /// <inheritdoc cref="Server.RelayFilter"/>
        /// </summary>
        public new MessageRelayFilter RelayFilter
        {
            get
            {
                return relayFilter;
            }
            [Obsolete("To use Encryptide, you must call SetRelayFilter() rather than setting RelayFilter directly.")]
            set
            {
                // This really isn't the nicest way to implement this, but because I need to know the message ids that are being relayed.
                // This seemed like the cleanest (but still hacky) option without submitting a pull request to Riptide.
                RiptideLogger.Log(LogType.Error, LogName, $"To use Encryptide, you must call SetRelayFilter() rather than setting RelayFilter directly.");
            }
        }

        #region RelayFilterHandling

        /// <summary>
        /// Sets RelayFilter (calls <see cref="MessageRelayFilter.MessageRelayFilter(Type, Enum[])"/>) 
        /// while saving the filter ids for custom message handling.
        /// </summary>
        /// <param name="idEnum"><inheritdoc cref="MessageRelayFilter.MessageRelayFilter(Type, Enum[])" path="/param[@name='idEnum']"/></param>
        /// <param name="idsToEnable"><inheritdoc cref="MessageRelayFilter.MessageRelayFilter(Type, Enum[])" path="/param[@name='idEnum']"/></param>
        public void SetRelayFilter(Type idEnum, params Enum[] idsToEnable)
        {
            relayFilterIds = idsToEnable.Cast<ushort>().ToList();
            relayFilter = new MessageRelayFilter(idEnum, idsToEnable);
        }

        /// <summary>
        /// Sets RelayFilter (calls <see cref="MessageRelayFilter.MessageRelayFilter(int, ushort[])"/>) 
        /// while saving the filter ids for custom message handling.
        /// </summary>
        /// <param name="size"><inheritdoc cref="MessageRelayFilter.MessageRelayFilter(int, ushort[])" path="/param[@name='size']"/></param>
        /// <param name="ids"><inheritdoc cref="MessageRelayFilter.MessageRelayFilter(int, ushort[])" path="/param[@name='ids']"/></param>
        public void SetRelayFilter(int size, params ushort[] ids)
        {
            relayFilterIds = ids.ToList();
            relayFilter = new MessageRelayFilter(size, ids);
        }

        #endregion

        #region Initialization
        public Server(string logName = "SERVER", string secret = null, bool encryptByDefault = false, bool randomPin = false) : base(logName)
        {
            // Create public/private RSA keys
            rsa = RSA.Create();

            // Create AES key
            aes = Aes.Create();

            if (randomPin) {
                PinNumber = GeneratePIN();
            }
            
            // Handle connections with a special function to start handshake process
            HandleConnection = HandleEncryptedConnection;

            if (secret != null)
            {
                // Set AppSecret that will need to match with any connecting clients
                AppSecret = secret;
            }
            this.encryptByDefault = encryptByDefault;
            this.randomPin = randomPin;
        }

        /// <summary>
        /// Generates a random PIN number.
        /// </summary>
        /// <returns></returns>
        private string GeneratePIN()
        {
            return _random.Next(0, 9999).ToString("D4");
        }

        /// <summary>
        /// Checks AppSecret value before calling the base function.
        /// </summary>
        public new void Start(ushort port, ushort maxClientCount, byte messageHandlerGroupId = 0)
        {
            if (AppSecret == null)
            {
                RiptideLogger.Log(LogType.Warning, LogName, $"AppSecret was not set. Please set AppSecret in order to accept connections.");
            }
            base.Start(port, maxClientCount, messageHandlerGroupId);
        }
        #endregion

        #region SendAndReceive
        /// <summary>
        /// Sends a message to a given client with the option to encrypt the message.
        /// </summary>
        /// <param name="message">Message to send.</param>
        /// <param name="toClient">Client to send the message to.</param>
        /// <param name="shouldRelease">Whether message should be released at the end.</param>
        /// <param name="encryption">Whether message data should be encrypted</param>
        public void Send(Message message, Connection toClient, bool shouldRelease = true, Encryption encryption = Encryption.Default)
        {
            message = this.PrepareMessageToSend(message, encryption);
            base.Send(message, toClient, shouldRelease);
        }

        /// <summary>
        /// Sends a message to a given client with the option to encrypt the message.
        /// </summary>
        /// <param name="message">Message to send.</param>
        /// <param name="toClient">Client to send the message to.</param>
        /// <param name="shouldRelease">Whether message should be released at the end.</param>
        /// <param name="encryption">Whether message data should be encrypted</param>
        public void Send(Message message, ushort toClient, bool shouldRelease = true, Encryption encryption = Encryption.Default)
        {
            message = this.PrepareMessageToSend(message, encryption);
            base.Send(message, toClient, shouldRelease);
        }

        /// <summary>Sends a message to all connected clients.</summary>
        /// <param name="message">The message to send.</param>
        /// <param name="shouldRelease">Whether or not to return the message to the pool after it is sent.</param>
        /// <inheritdoc cref="Client.Send(Message, bool)"/>
        public void SendToAll(Message message, bool shouldRelease = true, Encryption encryption = Encryption.Default)
        {
            message = this.PrepareMessageToSend(message, encryption);
            base.SendToAll(message, shouldRelease);
        }
        /// <summary>Sends a message to all connected clients except the given one.</summary>
        /// <param name="message">The message to send.</param>
        /// <param name="exceptToClientId">The numeric ID of the client to <i>not</i> send the message to.</param>
        /// <param name="shouldRelease">Whether or not to return the message to the pool after it is sent.</param>
        /// <inheritdoc cref="Client.Send(Message, bool)"/>
        public void SendToAll(Message message, ushort exceptToClientId, bool shouldRelease = true, Encryption encryption = Encryption.Default)
        {
            message = this.PrepareMessageToSend(message, encryption);
            base.SendToAll(message, exceptToClientId, shouldRelease);
        }

        /// <summary>Adds missing data back in (encryption byte) when relaying.</summary>
        /// <param name="message">The received message.</param>
        /// <param name="fromConnection">The client from which the message was received.</param>
        protected override void OnMessageReceived(Message message, Connection fromConnection)
        {
            // Read the message id from the message (message is re-packaged to its original format)
            ushort messageId = ReadMessageId(ref message);

            // If we're not relaying, we need to process the message (get rid of the encryption byte, decrypt if needed)
            // If we are relaying, we keep the message as-is and send it on
            if (relayFilterIds != null) {
                if (!relayFilterIds.Contains(messageId))
                {
                    message = ProcessMessage(message);
                }
            }
            else {
                message = ProcessMessage(message);
            }

            base.OnMessageReceived(message, fromConnection);
        }


        /// <summary>
        /// Reads the message id. Repackages the message to its original format, unlike calling message.GetUShort().
        /// </summary>
        /// <param name="message"></param>
        /// <returns></returns>
        private ushort ReadMessageId(ref Message message)
        {
            // Get the message id
            ushort messageId = message.GetUShort();

            // Get the encryption type
            byte encryption = message.GetByte();
            // Get the data
            byte[] data = message.GetBytes(message.UnreadLength);

            // Recreate the message (basically resets the readPos/writePos of the message)
            message = Message.Create(message.SendMode, messageId);
            message.AddByte(encryption);
            message.AddBytes(data, false);

            return messageId;
        }
        #endregion

        #region ConnectionHandshake
        /// <summary>
        /// Overrides Server's Handle method to allow a custom handshake.
        /// </summary>
        /// <param name="message"></param>
        /// <param name="header"></param>
        /// <param name="connection"></param>
        protected override void Handle(Message message, MessageHeader header, Connection connection)
        {
            // Reliable messages sent without a connection are part of the handshake process
            if (header == MessageHeader.Reliable && !connection.IsConnected)
            {
                // Process the message (decrypt if encrypted)
                message = ProcessMessage(message);

                ushort messageId = message.GetUShort();
                switch (messageId)
                {
                    // Received encrypted AppSecret from client
                    case (ushort)HandshakeMessageId.AppSecret:
                        RiptideLogger.Log(LogType.Info, LogName, $"Received identification information from client {connection}.");
                        // Read and validate the app secret
                        byte[] encryptedAppSecret = message.GetBytes();

                        byte[] encryptedPin = message.GetBytes(); // new!

                        ValidatePendingConnection(encryptedAppSecret, encryptedPin, connection);
                        break;
                    default:
                        break;
                }
                message.Release();
                return;
            }

            base.Handle(message, header, connection);
        }

        /// <summary>
        /// Handles a pending connection, begins encryption handshake.
        /// </summary>
        /// <param name="pendingConnection">Pending connection.</param>
        /// <param name="connectMessage">Message containing connection information.</param>
        public void HandleEncryptedConnection(Connection pendingConnection, Message connectMessage)
        {
            // We can only accept connections if we have a non-null AppSecret
            if (AppSecret == null)
            {
                RiptideLogger.Log(LogType.Warning, LogName, $"Rejecting connection request from {pendingConnection} because AppSecret was not set. Please set AppSecret in order to accept connections.");
                Reject(pendingConnection);
                return;
            }

            // When a client connects, store its public RSA key, send it your own public RSA key
            RiptideLogger.Log(LogType.Info, LogName, $"Received connection request from {pendingConnection}. Sending public encryption data...");

            // Store our pending connection
            pendingConnections.Add(pendingConnection.ToString(), pendingConnection);

            // Get the connection's public key parameters from connectMessage
            RSAParameters connectParameters = new RSAParameters();
            connectParameters.Modulus = connectMessage.GetBytes(128); // Get modulus (128 bytes)
            connectParameters.Exponent = connectMessage.GetBytes(3);    // Get exponent (3 bytes)

            // Store the connection's public key parameters
            pendingConnectionsEncryptionData.Add(pendingConnection.ToString(), RSA.Create(connectParameters));//connectParameters);

            // Create a message to send the public RSA key
            Message message = Message.Create(MessageSendMode.Reliable, (ushort)HandshakeMessageId.AsymmetricKey);

            // Export our public key parameters, add them to the message
            RSAParameters publicParameters = rsa.ExportParameters(false);
            message.AddBytes(publicParameters.Modulus, false);
            message.AddBytes(publicParameters.Exponent, false);

            // Send the data to the client. No encryption since we're sending a public key
            Send(message, pendingConnection, encryption: Encryption.None);
        }

        /// <summary>
        /// Checks whether encrypted app secret matches the stored secret. Accepts or rejects based on this.
        /// </summary>
        /// <param name="encryptedAppSecret">Encrypted AppSecret value.</param>
        /// <param name="connection">Pending connection.</param>
        private void ValidatePendingConnection(byte[] encryptedAppSecret, byte[] encryptedPin, Connection connection)
        {
            if (ValidateAppSecret(encryptedAppSecret) && ValidatePin(encryptedPin))
            {
                RiptideLogger.Log(LogType.Info, LogName, $"Successfully authenticated client {connection}.");
                AcceptConnection(connection);
            }
            else
            {
                RiptideLogger.Log(LogType.Info, LogName, $"Client {connection} unauthorized, disconnecting client.");
                RejectConnection(connection);
            }
        }

        /// <summary>
        /// Checks whether the encrypted value provided is the AppSecret.
        /// </summary>
        /// <param name="encryptedAppSecret">Encrypted AppSecret.</param>
        /// <returns></returns>
        private bool ValidateAppSecret(byte[] encryptedAppSecret)
        {
            // Decrypt the app secret
            byte[] decryptedAppSecret = rsa.Decrypt(encryptedAppSecret);

            // Return whether it matches the app secret
            return (Encoding.UTF8.GetString(decryptedAppSecret, 0, decryptedAppSecret.Length) == AppSecret);
        }

        /// <summary>
        /// Checks whether the encrypted value provided is the pin number.
        /// </summary>
        /// <param name="encryptedPin">Encrypted pin.</param>
        /// <returns></returns>
        private bool ValidatePin(byte[] encryptedPin)
        {
            byte[] decryptedPin = rsa.Decrypt(encryptedPin);
            return (Encoding.UTF8.GetString(decryptedPin, 0, decryptedPin.Length) == PinNumber);
        }

        /// <summary>
        /// Accepts a pending connection.
        /// </summary>
        /// <param name="connection">Pending connection.</param>
        private void AcceptConnection(Connection connection)
        {
            // Encrypt the AES key using the connection's public RSA key
            byte[] encryptedSymmetricKey = pendingConnectionsEncryptionData[connection.ToString()].Encrypt(aes.Key);
            byte[] encryptedSymmetricIV = pendingConnectionsEncryptionData[connection.ToString()].Encrypt(aes.IV);

            // Create a message containing the encrypted Aes session key
            Message encryptedAESMessage = Message.Create(MessageSendMode.Reliable, HandshakeMessageId.SymmetricKey);
            encryptedAESMessage.AddBytes(encryptedSymmetricKey);
            encryptedAESMessage.AddBytes(encryptedSymmetricIV);

            // Send the encrypted Aes session key to the client. Already encrypted, set encrypt to false
            Send(encryptedAESMessage, pendingConnections[connection.ToString()], encryption: Encryption.None);

            // Accept the connection, remove from pending connections
            Accept(pendingConnections[connection.ToString()]);
        }

        /// <summary>
        /// Rejects a connection.
        /// </summary>
        /// <param name="connection">Connection to reject.</param>
        private void RejectConnection(Connection connection)
        {
            Reject(pendingConnections[connection.ToString()]);
            pendingConnections.Remove(connection.ToString());
        }

        /// <summary>
        /// Make sure we remove the client from pending connections after they connect.
        /// </summary>
        /// <param name="client">Connected client.</param>
        protected override void OnClientConnected(Connection client)
        {
            base.OnClientConnected(client);
            pendingConnections.Remove(client.ToString());
            pendingConnectionsEncryptionData.Remove(client.ToString());
        }
        #endregion

        #region EncryptAndDecrypt
        /// <summary>
        /// Upon receiving a message, remove encrypted byte and possibly decrypt.
        /// </summary>
        /// <param name="message">Message to process.</param>
        /// <returns>A normal message without the encrypt byte.</returns>
        private Message ProcessMessage(Message message)
        {
            // Get the message id
            ushort messageId = message.GetUShort();
            
            // Get the encryption type
            byte encryption = message.GetByte();
            // Get the data
            byte[] data = message.GetBytes(message.UnreadLength);

            // Recreate the message (basically resets the readPos/writePos of the message)
            message = Message.Create(message.SendMode, messageId);

            // If the message was encrypted, decrypt it and add the decrypted bytes to the message
            if (encryption == 1)
            {
                byte[] decryptedData = aes.Decrypt(data);
                message.AddBytes(decryptedData, false);
            }
            // If the message isn't encrypted, just add the data as-is
            else
            {
                message.AddBytes(data, false);
            }
            return message;
        }

        /// <summary>
        /// Prepares message to be sent by adding an encryption byte and possibly encrypting the data.
        /// </summary>
        /// <param name="message">Message to be sent.</param>
        /// <param name="encrypt">Whether or not to encrypt the data.</param>
        /// <returns>The prepared message.</returns>
        private Message PrepareMessageToSend(Message message, Encryption encryption)
        {
            // Get the id
            ushort messageId = message.GetUShort();

            // Get the entire length of bytes following
            byte[] bytes = message.GetBytes(message.UnreadLength);

            // Recreate the message (basically resets the readPos/writePos of the message)
            message = Message.Create(message.SendMode, messageId);

            // Add a byte that specifies whether the message is encrypted
            if (encryption == Encryption.None || encryption == Encryption.Aes)
            {
                message.AddByte((byte)encryption);
            }
            else if (encryption == Encryption.Default)
            {
                if (encryptByDefault)
                {
                    message.AddByte((byte)1);
                }
                else
                {
                    message.AddByte((byte)0);
                }
            }

            // If we want to encrypt, add the encrypted bytes. If not, add the bytes as-is
            if (encryption == Encryption.Aes || (encryption == Encryption.Default && encryptByDefault))
            {
                message.AddBytes(aes.Encrypt(bytes), false);
            }
            else
            {
                message.AddBytes(bytes, false);
            }
            return message;
        }
        #endregion
    }
}
